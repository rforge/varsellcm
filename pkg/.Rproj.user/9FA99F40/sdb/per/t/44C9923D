{
    "contents" : "#include <iostream>\n#include <iomanip>\n#include <RcppArmadillo.h>\n#include <Rcpp.h>\n#include <math.h> \n\nusing namespace std;\nusing namespace arma;\nusing namespace Rcpp;\n#include \"Algo.h\"\n\nAlgo::Algo(const S4 &  obj){\n  this->x = as<mat>(obj.slot(\"data\"));\n  S4 model = obj.slot(\"model\");\n  this->omega = as<vec>(model.slot(\"omega\"));\n  this->g = model.slot(\"g\");\n  S4 partitions = obj.slot(\"partitions\");\n  this->z  = as<vec>(partitions.slot(\"zOPT\")); \n  this->micl = log(0);\n  this->priors = as<mat>(obj.slot(\"priors\"));\n  micl = Integre_Complete_Like(z);\n}\n\n\n\n\ndouble logdinvgamma(const double & x, const double & alpha, const double  & beta){\n  return alpha*log(beta) - lgamma(alpha) - (alpha+1)*log(x) - beta/x ;\n}\n\n\ndouble IntegreOneVariable(const vec & v, const double & nu, const double & s0, const double & mu,  const double & n0){\n  double output = 0;\n  double n = v.n_rows;\n // cout << n << (n>0) << endl ;\n  if (n> 0){ \n   // cout << \"ok\" << endl << endl;\n    double n1 = n + n0;\n    double theta1 = (n0*mu + n*mean(v))/n1;\n    double s1 = sqrt( s0*s0 + var(v) *(n-1)  + pow((mu - mean(v)),2) /(1/n0 + 1/n)  );\n    output =  -log(sqrt( M_PI))*n + lgamma((n + nu)*0.5) - lgamma(nu*0.5) +   nu * log(s0/s1) - n*log(s1) + log(sqrt(n0 / n1) );\n  }\n  return output;\n  \n}\n\n\ndouble Algo::Integre_Complete_Like(vec partition){\n  double outmicl = lgamma(g*0.5) - g*lgamma(0.5) - lgamma(x.n_rows + g*0.5);\n  for (int k=0; k<g; k++){\n    outmicl += lgamma(sum(partition==k) + 0.5);\n  }\n  for (int j=0; j<x.n_cols; j++){\n    if (omega(j)==0){\n      outmicl +=  IntegreOneVariable(x.col(j), priors(j,0), priors(j,1), priors(j,2), priors(j,3));\n    }else{\n      vec tmp = x.col(j);\n      for (int k=0; k<g; k++){\n        vec sup=(tmp(find(partition == k)));\n         // cout << sup.n_rows << endl;\n         outmicl +=  IntegreOneVariable(tmp(find(partition == k)), priors(j,0), priors(j,1), priors(j,2), priors(j,3));\n        \n      }\n    }\n  }\n  return outmicl;\n}\n\n\nvoid Algo::Optimize_partition(){\n  int chgt = x.n_rows ;\n  vec z_cand=z;\n  double critere_cand;\n  while (chgt > 0 ){\n    ivec who = randi<ivec>(chgt, distr_param(0, x.n_rows -1));\n    chgt = 0;\n\n    for (int it=0; it < who.n_rows; it++){ \n      for (int k=0; k<g; k++){\n          z_cand( who(it) ) = k;\n          critere_cand = Integre_Complete_Like( z_cand );\n          if (critere_cand > micl){\n            z(who(it)) = k;\n            micl = critere_cand;\n            chgt = it ;\n        }\n      }\n      z_cand( who(it) ) = z( who(it) );\n    }\n  }\n\n}\n\n\nvoid Algo::Optimize_model(){\n  micl = lgamma(g*0.5) - g*lgamma(0.5) - lgamma(x.n_rows + g*0.5);\n  for (int k=0; k<g; k++){\n    micl += lgamma(sum(z==k) + 0.5);\n  }\n  double nondiscrim=0;\n  double discrim=0;\n  for (int j=0; j<x.n_cols; j++){\n    nondiscrim = IntegreOneVariable(x.col(j), priors(j,0), priors(j,1), priors(j,2), priors(j,3));\n    discrim = 0;\n    vec tmp = x.col(j);\n    for (int k=0; k<g; k++){\n      discrim += IntegreOneVariable(tmp(find(z == k)), priors(j,0), priors(j,1), priors(j,2), priors(j,3));\n    }\n    if (discrim > nondiscrim){\n      omega(j) = 1;\n      micl +=  discrim ;\n    }else{\n      omega(j) = 0 ;\n      micl +=  nondiscrim ;\n    }      \n  }\n}\n\n\nvoid Algo::Run(){\n  double prec = log(0);\n  while (prec < micl){\n    prec = micl;\n    Optimize_model();\n    if (sum(omega)>0){\n      Optimize_partition();\n    }\n    Optimize_model();\n  }\n}",
    "created" : 1418132825290.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "815588605",
    "id" : "44C9923D",
    "lastKnownWriteTime" : 1418143623,
    "path" : "~/Documents/Recherche/variable_selection/package/VarSelLCM/src/Algo.cpp",
    "project_path" : "src/Algo.cpp",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "cpp"
}